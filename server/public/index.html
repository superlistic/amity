<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>be more</title>
  </head>
  <body>
    <input id="username" type="text" /><input
      type="button"
      value="relay"
      onClick="relay()"
    />
    <input type="button" value="disconnect" onClick="disconnect()" />
    <input type="button" value="dataChannel" onClick="showDataChannel()" />
    <input
      type="button"
      value="localConnection"
      onClick="showlocalConnection()"
    />
    <input type="button" value="webRTC send" onClick="sendOnDataChannel()" />
    <input type="button" value="NoOp" onClick="NoOp()" />
    <ul id="events"></ul>

    <script src="/socket.io/socket.io.js"></script>
    <script>
    // HELPER
      const $events = document.getElementById('events');

      const newItem = content => {
        const item = document.createElement('li');
        item.innerText = content;
        return item;
      };
      const log = (msg, data = "") => {
        $events.appendChild(
          newItem(msg))
          console.log(msg,":", data)
        }
      const logVerbose = (msg, data = "null") => {
        $events.appendChild(
          newItem(msg + data))
          console.log(msg,":", data)
        }

      
      const socket = io();
      let peerConnection, dataChannel;


      const relay = () => {
        const msg = document.querySelector('#username').value;
        socket.emit('relay', {type:"-TEST-", msg: msg });
        logVerbose("relay: EMIT, ", msg);
      };
      
      const disconnect = () => {
        const username = document.querySelector('#username').value;
        socket.disconnect();
        log("socket.disconnect()")
      };
      
        const showDataChannel = () => {
        logVerbose('logged:' , dataChannel)
      };
      const showlocalConnection = () => {
        logVerbose('logged:' , peerConnection)

      };
      const sendOnDataChannel = () => {
        const msg = document.querySelector('#username').value;
        dataChannel.send(msg);
        logVerbose('dataChannel: SEND' , msg)

      };

      const createDataChannel = () =>{
        dataChannel = peerConnection.createDataChannel('messages');
        dataChannel.onmessage = e => log('got message', e)
        dataChannel.onopen = e => log('connection opened', e)
        peerConnection.onicecandidate = e => log('"A"..onicecandidate', e)
      }

      const setOnDataChannel = () =>{
        log('setOnDataChannel()')
        peerConnection.ondatachannel = e => {
          log('peerConnection: dataChannel',e );
          dataChannel = e.channel;
          dataChannel.onmessage = msg => {
            logVerbose("dataChannel: message",msg);
          };
          dataChannel.onopen = e => {
            log('dataChannel: open',e)
          };
        };
      }
      socket.on('connect', e => {
        log('socket: connect', e)
      });
      // AWAIT OFFER
      socket.on('awaitOffer', payload => {
        $events.innerHTML = "";
        log('socket: awaitOffer', payload)
        peerConnection = new RTCPeerConnection()
        peerConnection.onicecandidate = e => log('"B"..onicecandidate', e);
        setOnDataChannel(peerConnection);
      })

      socket.on('makeOffer', payload => {
        $events.innerHTML = "";
        log('socket: makeOffer: ', payload)
        peerConnection = new RTCPeerConnection();
        setOnDataChannel(peerConnection);

        peerConnection
          .createOffer()
          .then(offer => {
            peerConnection.setLocalDescription(offer)
            .then(()=>{
            log('offer: SET as local', offer)
            socket.emit('relay', { type: 'offer', data: offer });
            log('offer: SENT', offer)
          })
        })
        .catch(err => log("make offer ERROR",err));
      });
      socket.on('relay', payload => {
        switch (payload.type) {
          // OFFER
          case 'offer':
            log('offer: RECIEVED', payload);
            peerConnection.setRemoteDescription(payload.data)
            .then(() => {
              log('offer: SET as remote', payload.data);
              peerConnection.createAnswer().then(answer => {
                log('answer: CREATED', answer);
                peerConnection.setLocalDescription(answer)
                .then(() => {
                  log('answere: SET as local', answer);
                  socket.emit('relay', { type: 'answer', data: answer });
                  log('answere: SENT', answer);
                });
              });
            })
            .catch(err => log("got offer ERROR",err));
            break;
          // ANSWER
          case 'answer':
            peerConnection.setRemoteDescription(payload.data)
            .then(()=>log("set answer as remote desc", payload.data));
            break;

          default:
            break;
        }
      });
    </script>
  </body>
</html>
